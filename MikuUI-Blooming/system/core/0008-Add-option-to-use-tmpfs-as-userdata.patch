From d9178513411cbf58e76b68f7117b316cce2bef34 Mon Sep 17 00:00:00 2001
From: Yumi Yukimura <me.cafebabe@gmail.com>
Date: Sat, 5 Jul 2025 05:39:31 +0800
Subject: [PATCH 08/11] Add option to use tmpfs as userdata

* Helps testing ROM on devices containing important userdata
* Set GSI running prop to offset gatekeeper UID, to avoid
  breaking userdata encryption after going back to primary ROM

Change-Id: I82d12a46c962b4d54d0ca27097ae9e5becdc1184
---
 fs_mgr/libfstab/fstab.cpp | 41 +++++++++++++++++++++++++++++++++++++++
 init/init.cpp             |  5 +++--
 2 files changed, 44 insertions(+), 2 deletions(-)

diff --git a/fs_mgr/libfstab/fstab.cpp b/fs_mgr/libfstab/fstab.cpp
index ec23ce5cf1..c54c21eb87 100644
--- a/fs_mgr/libfstab/fstab.cpp
+++ b/fs_mgr/libfstab/fstab.cpp
@@ -26,6 +26,7 @@
 
 #include <algorithm>
 #include <array>
+#include <unordered_map>
 #include <utility>
 #include <vector>
 
@@ -574,6 +575,44 @@ std::string GetFstabPath() {
     return "";
 }
 
+namespace {
+
+void TransformFstabForTmpfsUserdata(Fstab* fstab) {
+    std::string tmp;
+    if (!fs_mgr_get_boot_config("use_tmpfs_userdata", &tmp)) return;
+
+    std::unordered_map<std::string, bool> mountpoints = {
+        {"/cache", false},
+        {"/data", true},
+        {"/metadata", true},
+    };
+
+    std::erase_if(*fstab, [&mountpoints](const FstabEntry& e) {
+        auto it = mountpoints.find(e.mount_point);
+        if (it != mountpoints.end()) {
+            it->second = true;
+            return true;
+        }
+        return false;
+    });
+
+    for (const auto& m : mountpoints) {
+        if (!m.second) continue;
+        LINFO << __FUNCTION__ << "(): Transform fstab entry "
+              << m.first << " for tmpfs";
+
+        FstabEntry entry;
+        entry.blk_device = m.first.substr(1);
+        entry.fs_mgr_flags.late_mount = true;
+        entry.fs_type = "tmpfs";
+        entry.mount_point = m.first;
+
+        fstab->push_back(entry);
+    }
+}
+
+}  // namespace
+
 bool ParseFstabFromString(const std::string& fstab_str, bool proc_mounts, Fstab* fstab_out) {
     const int expected_fields = proc_mounts ? 4 : 5;
 
@@ -619,6 +658,8 @@ bool ParseFstabFromString(const std::string& fstab_str, bool proc_mounts, Fstab*
         return false;
     }
 
+    TransformFstabForTmpfsUserdata(&fstab);
+
     /* If an A/B partition, modify block device to be the real block device */
     if (!fs_mgr_update_for_slotselect(&fstab)) {
         LERROR << "Error updating for slotselect";
diff --git a/init/init.cpp b/init/init.cpp
index de80807e01..54d6dcf591 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -1096,8 +1096,9 @@ int SecondStageMain(int argc, char** argv) {
     if (false) DumpState();
 
     // Make the GSI status available before scripts start running.
-    auto is_running = android::gsi::IsGsiRunning() ? "1" : "0";
-    SetProperty(gsi::kGsiBootedProp, is_running);
+    bool is_running = android::gsi::IsGsiRunning() ||
+                      !GetProperty("ro.boot.use_tmpfs_userdata", "").empty();
+    SetProperty(gsi::kGsiBootedProp, is_running ? "1" : "0");
     auto is_installed = android::gsi::IsGsiInstalled() ? "1" : "0";
     SetProperty(gsi::kGsiInstalledProp, is_installed);
     if (android::gsi::IsGsiRunning()) {
-- 
2.39.5

