From 23327f41c533e8e676395ed8fb41c676c36338df Mon Sep 17 00:00:00 2001
From: Yumi Yukimura <me.cafebabe@gmail.com>
Date: Fri, 18 Jul 2025 05:10:01 +0800
Subject: [PATCH 18/27] libfstab: Add support for boot config
 `mount_on_oem_which_contain`

This mounts block devices from physical disks containing paths
specified by the boot config value, separated by ";", on /oem.

Change-Id: Iafd67682f23922db163d97da35138f758d6a4af1
---
 fs_mgr/libfstab/fstab.cpp | 58 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/fs_mgr/libfstab/fstab.cpp b/fs_mgr/libfstab/fstab.cpp
index 80b0304c53..75c8ede36f 100644
--- a/fs_mgr/libfstab/fstab.cpp
+++ b/fs_mgr/libfstab/fstab.cpp
@@ -26,6 +26,7 @@
 
 #include <algorithm>
 #include <array>
+#include <filesystem>
 #include <unordered_map>
 #include <utility>
 #include <vector>
@@ -907,9 +908,66 @@ bool SkipMountWithConfig(const std::string& skip_mount_config, Fstab* fstab, boo
     return true;
 }
 
+namespace {
+
+void AddOemMountpointContainingPathFstabEntries(Fstab* fstab) {
+    std::string contain;
+    if (!fs_mgr_get_boot_config("mount_on_oem_which_contain", &contain)) return;
+    LINFO << __FUNCTION__ << "(): Boot config value: " << contain;
+
+#if defined(__ANDROID_RAMDISK__)
+    // Block devices like USB drives may need some time to appear...
+    LINFO << __FUNCTION__ << "(): Delaying";
+    sleep(3);
+#endif
+
+    std::vector<std::string> blk_devices;
+
+    for (const auto& entry : std::filesystem::directory_iterator("/sys/block")) {
+        std::string name = entry.path().filename().string();
+        if (!android::base::StartsWith(name, ".") && !android::base::StartsWith(name, "dm-") &&
+            !android::base::StartsWith(name, "loop") && !android::base::StartsWith(name, "ram") &&
+            !android::base::StartsWith(name, "zram")) {
+            for (const auto& sentry : std::filesystem::directory_iterator("/sys/block/" + name)) {
+                std::string sname = sentry.path().filename().string();
+                if (android::base::StartsWith(sname, name)) {
+                    LINFO << __FUNCTION__ << "(): Found block device " << sname;
+                    blk_devices.push_back(sname);
+                }
+            }
+            LINFO << __FUNCTION__ << "(): Found block device " << name;
+            blk_devices.push_back(name);
+        }
+    }
+
+    if (blk_devices.empty()) return;
+
+    const std::vector<std::string> filesystems = {"erofs",   "exfat", "ext4",     "f2fs",
+                                                  "iso9660", "ntfs",  "squashfs", "vfat"};
+
+    for (const auto& bdev : blk_devices) {
+        for (const auto& fs : filesystems) {
+            FstabEntry entry;
+
+            entry.blk_device = "/dev/block/" + bdev;
+            entry.ensure_path_accessible = Split(contain, ";");
+            entry.mount_point = "/oem";
+            entry.fs_mgr_flags.first_stage_mount = true;
+            entry.fs_type = fs;
+
+            fstab->push_back(std::move(entry));
+        }
+    }
+}
+
+}  // namespace
+
 // Loads the fstab file and combines with fstab entries passed in from device tree.
 bool ReadDefaultFstab(Fstab* fstab) {
     fstab->clear();
+
+    AddOemMountpointContainingPathFstabEntries(fstab);
+
     ReadFstabFromDt(fstab, false /* verbose */);
 
     Fstab default_fstab;
-- 
2.39.5

