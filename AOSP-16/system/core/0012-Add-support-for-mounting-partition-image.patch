From 3c5e8a289f95e012572059f09a74c5760b8f3b58 Mon Sep 17 00:00:00 2001
From: Yumi Yukimura <me.cafebabe@gmail.com>
Date: Sat, 5 Jul 2025 17:57:10 +0800
Subject: [PATCH 12/27] Add support for mounting partition image

Change-Id: I4aaec7e838ef6009ddf76439e77e1b634abb7345
---
 fs_mgr/fs_mgr.cpp                         | 62 +++++++++++++++++++++++
 fs_mgr/include/fs_mgr.h                   |  3 ++
 fs_mgr/libdm/include/libdm/loop_control.h |  3 ++
 fs_mgr/libdm/loop_control.cpp             | 42 +++++++++++++++
 fs_mgr/libfstab/fstab.cpp                 |  2 +-
 init/first_stage_mount.cpp                | 24 +++++++--
 6 files changed, 132 insertions(+), 4 deletions(-)

diff --git a/fs_mgr/fs_mgr.cpp b/fs_mgr/fs_mgr.cpp
index 204e690936..c32db9e7e0 100644
--- a/fs_mgr/fs_mgr.cpp
+++ b/fs_mgr/fs_mgr.cpp
@@ -965,6 +965,11 @@ static bool mount_with_alternatives(Fstab& fstab, int start_idx, bool interrupte
             fstab[i].blk_device = fstab[start_idx].blk_device;
         }
 
+        if ((i != start_idx) &&
+            android::base::StartsWith(fstab[i].blk_device, "/dev/block/loop")) {
+            fstab[i].blk_device = fstab[start_idx].blk_device;
+        }
+
         int fs_stat = prepare_fs_for_mount(fstab[i].blk_device, fstab[i]);
         if (fs_stat & FS_STAT_INVALID_MAGIC) {
             LERROR << __FUNCTION__
@@ -1121,6 +1126,60 @@ static bool call_vdc(const std::vector<std::string>& args, int* ret) {
     return true;
 }
 
+bool fs_mgr_update_partition_image(FstabEntry* entry) {
+    if (!android::base::EndsWithIgnoreCase(entry->blk_device, ".img")) return true;
+
+    bool ro = entry->flags & MS_RDONLY;
+
+    unique_fd image_fd(TEMP_FAILURE_RETRY(open(entry->blk_device.c_str(), (ro ? O_RDONLY : O_RDWR) | O_CLOEXEC, (ro ? 0400 : 0600))));
+    if (image_fd.get() == -1) {
+        PERROR << "Cannot open image path: " << entry->blk_device;
+        return false;
+    }
+
+    LoopControl loop_control;
+    std::string loop_device;
+    if (!loop_control.Attach(image_fd.get(), 5s, &loop_device)) {
+        return false;
+    }
+
+    unique_fd loop_fd(TEMP_FAILURE_RETRY(open(loop_device.c_str(), O_RDWR | O_CLOEXEC)));
+    if (loop_fd.get() == -1) {
+        PERROR << "Cannot open " << loop_device;
+        return false;
+    }
+
+    unsigned int flags = 0;
+    if (ro) flags |= LO_FLAGS_READ_ONLY;
+    if (!LoopControl::SetStatusFlags(loop_fd.get(), flags)) {
+        PERROR << "Failed set loop flags for " << loop_device;
+        return false;
+    }
+
+    LoopControl::EnableDirectIo(loop_fd.get());
+
+    entry->blk_device = loop_device;
+
+    return true;
+}
+
+bool fs_mgr_detach_partition_image(FstabEntry* entry) {
+    if (!android::base::StartsWith(entry->blk_device, "/dev/block/loop")) return true;
+
+    unique_fd loop_fd(TEMP_FAILURE_RETRY(open(entry->blk_device.c_str(), O_RDWR | O_CLOEXEC)));
+    if (loop_fd.get() == -1) {
+        PERROR << "Cannot open " << entry->blk_device;
+        return false;
+    }
+
+    if (ioctl(loop_fd.get(), LOOP_CLR_FD, 0)) {
+        PLOG(ERROR) << "Failed LOOP_CLR_FD for '" << entry->blk_device << "'";
+        return false;
+    }
+
+    return true;
+}
+
 bool fs_mgr_update_logical_partition(FstabEntry* entry) {
     // Logical partitions are specified with a named partition rather than a
     // block device, so if the block device is a path, then it has already
@@ -1531,6 +1590,8 @@ int fs_mgr_mount_all(Fstab* fstab, int mount_mode) {
             }
         }
 
+        fs_mgr_update_partition_image(&current_entry);
+
         if (current_entry.fs_mgr_flags.logical) {
             if (!fs_mgr_update_logical_partition(&current_entry)) {
                 LERROR << "Could not set up logical partition, skipping!";
@@ -1715,6 +1776,7 @@ int fs_mgr_mount_all(Fstab* fstab, int mount_mode) {
             }
             continue;
         }
+        fs_mgr_detach_partition_image(&current_entry);
     }
     if (userdata_mounted) {
         Fstab mounted_fstab;
diff --git a/fs_mgr/include/fs_mgr.h b/fs_mgr/include/fs_mgr.h
index 79690874e2..268f2559bb 100644
--- a/fs_mgr/include/fs_mgr.h
+++ b/fs_mgr/include/fs_mgr.h
@@ -87,6 +87,9 @@ std::optional<HashtreeInfo> fs_mgr_get_hashtree_info(const android::fs_mgr::Fsta
 bool fs_mgr_swapon_all(const android::fs_mgr::Fstab& fstab);
 bool fs_mgr_update_logical_partition(android::fs_mgr::FstabEntry* entry);
 
+bool fs_mgr_update_partition_image(android::fs_mgr::FstabEntry* entry);
+bool fs_mgr_detach_partition_image(android::fs_mgr::FstabEntry* entry);
+
 // Returns true if the given fstab entry has verity enabled, *and* the verity
 // device is in "check_at_most_once" mode.
 bool fs_mgr_verity_is_check_at_most_once(const android::fs_mgr::FstabEntry& entry);
diff --git a/fs_mgr/libdm/include/libdm/loop_control.h b/fs_mgr/libdm/include/libdm/loop_control.h
index f5190544e3..389c3edcef 100644
--- a/fs_mgr/libdm/include/libdm/loop_control.h
+++ b/fs_mgr/libdm/include/libdm/loop_control.h
@@ -49,6 +49,9 @@ class LoopControl final {
     // Set LO_FLAGS_AUTOCLEAR on a loop device.
     static bool SetAutoClearStatus(int fd);
 
+    // Set custom flags on a loop device.
+    static bool SetStatusFlags(int fd, unsigned int flags);
+
     LoopControl(const LoopControl&) = delete;
     LoopControl& operator=(const LoopControl&) = delete;
     LoopControl& operator=(LoopControl&&) = default;
diff --git a/fs_mgr/libdm/loop_control.cpp b/fs_mgr/libdm/loop_control.cpp
index 32d5f383e7..4c484cfc14 100644
--- a/fs_mgr/libdm/loop_control.cpp
+++ b/fs_mgr/libdm/loop_control.cpp
@@ -20,9 +20,11 @@
 #include <linux/loop.h>
 #include <stdint.h>
 #include <sys/ioctl.h>
+#include <sys/sysmacros.h>
 #include <sys/types.h>
 #include <unistd.h>
 
+#include <android-base/file.h>
 #include <android-base/logging.h>
 #include <android-base/stringprintf.h>
 #include <android-base/unique_fd.h>
@@ -33,6 +35,13 @@ namespace android {
 namespace dm {
 
 LoopControl::LoopControl() : control_fd_(-1) {
+#if defined(__ANDROID_RAMDISK__)
+    if (access(kLoopControlDevice, F_OK) != 0) {
+        if (mknod(kLoopControlDevice, S_IFCHR | 0660, makedev(10, 237)) == -1) {
+            PLOG(ERROR) << "Failed to mknod loop-control";
+        }
+    }
+#endif
     control_fd_.reset(TEMP_FAILURE_RETRY(open(kLoopControlDevice, O_RDWR | O_CLOEXEC)));
     if (control_fd_ < 0) {
         PLOG(ERROR) << "Failed to open loop-control";
@@ -109,6 +118,29 @@ bool LoopControl::FindFreeLoopDevice(std::string* loopdev) const {
     // The total number of available devices is determined by 'loop.max_part'
     // kernel command line argument.
     *loopdev = ::android::base::StringPrintf("/dev/block/loop%d", rc);
+
+#if defined(__ANDROID_RAMDISK__)
+    if (access(loopdev->c_str(), F_OK) != 0) {
+        std::string dev_content;
+        std::string dev_path = "/sys/class/block/loop" + std::to_string(rc) + "/dev";
+        if (!android::base::ReadFileToString(dev_path, &dev_content, true)) {
+            PLOG(ERROR) << "Failed to read " << dev_path;
+            return false;
+        }
+
+        unsigned int major, minor;
+        if (sscanf(dev_content.c_str(), "%d:%d", &major, &minor) != 2) {
+            PLOG(ERROR) << "Failed to parse " << dev_path << "content: " << dev_content;
+            return false;
+        }
+
+        if (mknod(loopdev->c_str(), S_IFBLK | 0660, makedev(major, minor)) == -1) {
+            PLOG(ERROR) << "Failed to mknod loop device";
+            return false;
+        }
+    }
+#endif
+
     return true;
 }
 
@@ -143,6 +175,16 @@ bool LoopControl::SetAutoClearStatus(int fd) {
     return true;
 }
 
+bool LoopControl::SetStatusFlags(int fd, unsigned int flags) {
+    struct loop_info64 info = {};
+
+    info.lo_flags |= flags;
+    if (ioctl(fd, LOOP_SET_STATUS64, &info)) {
+        return false;
+    }
+    return true;
+}
+
 LoopDevice::LoopDevice(android::base::borrowed_fd fd, const std::chrono::milliseconds& timeout_ms,
                        bool auto_close)
     : fd_(fd), owned_fd_(-1) {
diff --git a/fs_mgr/libfstab/fstab.cpp b/fs_mgr/libfstab/fstab.cpp
index a1f2ffffa1..0eb438dc12 100644
--- a/fs_mgr/libfstab/fstab.cpp
+++ b/fs_mgr/libfstab/fstab.cpp
@@ -650,7 +650,7 @@ bool ParseFstabFromString(const std::string& fstab_str, bool proc_mounts, Fstab*
             entry.logical_partition_name = entry.blk_device;
         }
 
-        fstab.emplace_back(std::move(entry));
+        fstab.push_back(std::move(entry));
     }
 
     if (fstab.empty()) {
diff --git a/init/first_stage_mount.cpp b/init/first_stage_mount.cpp
index 849ea75c73..3e76641d8a 100644
--- a/init/first_stage_mount.cpp
+++ b/init/first_stage_mount.cpp
@@ -440,6 +440,8 @@ bool FirstStageMountVBootV2::MountPartition(const Fstab::iterator& begin, bool e
         return false;
     }
 
+    fs_mgr_update_partition_image(&(*begin));
+
     if (begin->fs_mgr_flags.logical) {
         if (!fs_mgr_update_logical_partition(&(*begin))) {
             return false;
@@ -476,6 +478,9 @@ bool FirstStageMountVBootV2::MountPartition(const Fstab::iterator& begin, bool e
     if (end) {
         *end = current;
     }
+    if (!mounted) {
+        fs_mgr_detach_partition_image(&(*begin));
+    }
     return mounted;
 }
 
@@ -555,6 +560,15 @@ bool FirstStageMountVBootV2::TrySwitchSystemAsRoot() {
     return true;
 }
 
+static bool IsSystemFromImage(Fstab* fstab) {
+    auto search = std::find_if(fstab->begin(), fstab->end(), [](const auto& entry) {
+        return entry.mount_point == "/system" &&
+               android::base::EndsWithIgnoreCase(entry.blk_device, ".img");
+    });
+    if (search != fstab->end()) return true;
+    return false;
+}
+
 static bool MaybeDeriveMicrodroidVendorDiceNode(Fstab* fstab) {
     std::optional<std::string> microdroid_vendor_block_dev;
     for (auto entry = fstab->begin(); entry != fstab->end(); entry++) {
@@ -589,7 +603,7 @@ static bool MaybeDeriveMicrodroidVendorDiceNode(Fstab* fstab) {
 }
 
 bool FirstStageMountVBootV2::MountPartitions() {
-    if (!TrySwitchSystemAsRoot()) return false;
+    if (!IsSystemFromImage(&fstab_) && !TrySwitchSystemAsRoot()) return false;
 
     if (IsMicrodroid() && android::virtualization::IsOpenDiceChangesFlagEnabled()) {
         if (!MaybeDeriveMicrodroidVendorDiceNode(&fstab_)) {
@@ -600,8 +614,11 @@ bool FirstStageMountVBootV2::MountPartitions() {
     if (!SkipMountingPartitions(&fstab_, true /* verbose */)) return false;
 
     for (auto current = fstab_.begin(); current != fstab_.end();) {
-        // We've already mounted /system above.
         if (current->mount_point == "/system") {
+            if (android::base::EndsWithIgnoreCase(current->blk_device, ".img")) {
+                TrySwitchSystemAsRoot();
+            }
+            // We've already mounted /system above.
             ++current;
             continue;
         }
@@ -772,7 +789,8 @@ bool FirstStageMountVBootV2::GetDmVerityDevices(std::set<std::string>* devices)
             // Don't try to find logical partitions via uevent regeneration.
             logical_partitions.emplace(basename(fstab_entry.blk_device.c_str()));
         } else {
-            if (fstab_entry.fs_type != "none") {
+            if (fstab_entry.fs_type != "none" &&
+                !android::base::EndsWithIgnoreCase(fstab_entry.blk_device, ".img")) {
                 devices->emplace(basename(fstab_entry.blk_device.c_str()));
             }
         }
-- 
2.39.5

