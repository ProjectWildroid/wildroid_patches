From 7b60080468b1d62a4e8f7941c82bb026f1bd2bdd Mon Sep 17 00:00:00 2001
From: Yumi Yukimura <me.cafebabe@gmail.com>
Date: Sat, 5 Jul 2025 05:39:31 +0800
Subject: [PATCH 11/22] Add option to use tmpfs as userdata

* Helps testing ROM on devices containing important userdata
* Set GSI running prop to offset gatekeeper UID, to avoid
  breaking userdata encryption after going back to primary ROM

Change-Id: I82d12a46c962b4d54d0ca27097ae9e5becdc1184
---
 fs_mgr/libfstab/fstab.cpp  | 41 ++++++++++++++++++++++++++++++++++++++
 init/first_stage_mount.cpp |  4 +++-
 init/init.cpp              |  5 +++--
 3 files changed, 47 insertions(+), 3 deletions(-)

diff --git a/fs_mgr/libfstab/fstab.cpp b/fs_mgr/libfstab/fstab.cpp
index ec23ce5cf1..a1f2ffffa1 100644
--- a/fs_mgr/libfstab/fstab.cpp
+++ b/fs_mgr/libfstab/fstab.cpp
@@ -26,6 +26,7 @@
 
 #include <algorithm>
 #include <array>
+#include <unordered_map>
 #include <utility>
 #include <vector>
 
@@ -574,6 +575,44 @@ std::string GetFstabPath() {
     return "";
 }
 
+namespace {
+
+void TransformFstabForTmpfsUserdata(Fstab* fstab) {
+    std::string tmp;
+    if (!fs_mgr_get_boot_config("use_tmpfs_userdata", &tmp)) return;
+
+    std::unordered_map<std::string, bool> mountpoints = {
+            {"/cache", false},
+            {"/data", true},
+            {"/metadata", true},
+    };
+
+    std::erase_if(*fstab, [&mountpoints](const FstabEntry& e) {
+        auto it = mountpoints.find(e.mount_point);
+        if (it != mountpoints.end()) {
+            it->second = true;
+            return true;
+        }
+        return false;
+    });
+
+    for (const auto& m : mountpoints) {
+        if (!m.second) continue;
+        LINFO << __FUNCTION__ << "(): Transform fstab entry " << m.first << " for tmpfs";
+
+        FstabEntry entry;
+        entry.blk_device = m.first.substr(1);
+        entry.fs_mgr_flags.first_stage_mount = true;
+        entry.fs_mgr_flags.late_mount = true;
+        entry.fs_type = "tmpfs";
+        entry.mount_point = m.first;
+
+        fstab->push_back(entry);
+    }
+}
+
+}  // namespace
+
 bool ParseFstabFromString(const std::string& fstab_str, bool proc_mounts, Fstab* fstab_out) {
     const int expected_fields = proc_mounts ? 4 : 5;
 
@@ -619,6 +658,8 @@ bool ParseFstabFromString(const std::string& fstab_str, bool proc_mounts, Fstab*
         return false;
     }
 
+    TransformFstabForTmpfsUserdata(&fstab);
+
     /* If an A/B partition, modify block device to be the real block device */
     if (!fs_mgr_update_for_slotselect(&fstab)) {
         LERROR << "Error updating for slotselect";
diff --git a/init/first_stage_mount.cpp b/init/first_stage_mount.cpp
index 0647ef7c11..849ea75c73 100644
--- a/init/first_stage_mount.cpp
+++ b/init/first_stage_mount.cpp
@@ -772,7 +772,9 @@ bool FirstStageMountVBootV2::GetDmVerityDevices(std::set<std::string>* devices)
             // Don't try to find logical partitions via uevent regeneration.
             logical_partitions.emplace(basename(fstab_entry.blk_device.c_str()));
         } else {
-            devices->emplace(basename(fstab_entry.blk_device.c_str()));
+            if (fstab_entry.fs_type != "none") {
+                devices->emplace(basename(fstab_entry.blk_device.c_str()));
+            }
         }
     }
 
diff --git a/init/init.cpp b/init/init.cpp
index f6b2941365..711d39ac5e 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -1090,8 +1090,9 @@ int SecondStageMain(int argc, char** argv) {
     if (false) DumpState();
 
     // Make the GSI status available before scripts start running.
-    auto is_running = android::gsi::IsGsiRunning() ? "1" : "0";
-    SetProperty(gsi::kGsiBootedProp, is_running);
+    bool is_running = android::gsi::IsGsiRunning() ||
+                      !GetProperty("ro.boot.use_tmpfs_userdata", "").empty();
+    SetProperty(gsi::kGsiBootedProp, is_running ? "1" : "0");
     auto is_installed = android::gsi::IsGsiInstalled() ? "1" : "0";
     SetProperty(gsi::kGsiInstalledProp, is_installed);
     if (android::gsi::IsGsiRunning()) {
-- 
2.39.5

